'''
Goal: to make a playable synth
1. can select between Sin, Saw etc.
2. use keyboard keys as inputs to change frequency

Made by Advaith Suresh
'''

import math
import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile

# parent class
class Signal:
    def __init__(self, freq, ampl, phase = 0, sample_rate = 44100):
        self.frame = 0
        self.freq = freq
        self.ifreq = freq
        self.time_period = 1/freq
        self.ampl = ampl
        self.iampl = ampl
        self.phase = phase #phase in degrees
        self.sample_rate = sample_rate
    
    def __iter__(self):
        return self
    
    def __next__(self):
        pass

    def __add__(self):
        return 


# class implementing sin wave
class SinSignal(Signal):
    def __next__(self):
        self.frame += 1
        phase = 2*math.pi*(self.freq*self.frame/self.sample_rate + self.phase/360)
        return self.ampl*math.sin(phase)

#class implementing saw wave
class SawSignal(Signal):
    def __next__(self):
        self.frame += 1
        phase = 2*math.pi*(self.freq*self.frame/self.sample_rate + self.phase/360)
        mod_phase = phase - (phase//(2*math.pi))*2*math.pi

        y = 2*((self.ampl-0)/(self.time_period - 0))*(mod_phase/(2*math.pi*self.freq) - 0) - self.ampl
        return y

# class implementing square wave
class SquareSignal(Signal):
    def __init__(self, freq, ampl, phase=0, duty = 0.5, sample_rate=44100):
        super().__init__(freq, ampl, phase, sample_rate)
        self.duty = duty

    def __next__(self):
        self.frame += 1
        phase = 2*math.pi*(self.freq*self.frame/self.sample_rate + self.phase/360)

        if (phase - (phase//(2*math.pi))*2*math.pi) <= self.duty*2*math.pi:
            return self.ampl
        else:
            return -self.ampl 

# class to store the values from the oscillator
class Wave:
    def __init__(self, secs, signal=0, sample_rate = 44100): 
        self.num_frames = secs * sample_rate
        self.sample_rate = sample_rate
        self.samples_t = np.array(range(0, int(self.num_frames), 1))/self.num_frames
        # handwavy way of checking if we need a signal or not
        if not isinstance(signal, int):
            self.samples_y = np.array([next(signal) for i in range(self.num_frames)])

    def __add__(self, wave2):
        if self.num_frames != wave2.num_frames:
            raise ValueError
        elif self.num_frames != wave2.num_frames:
            raise ValueError
        else:
            new_wave = Wave(self.num_frames/self.sample_rate) #to convert back to num_frames
            new_wave.samples_y = self.samples_y + wave2.samples_y
            return new_wave
    
    # plotting the values 
    def plot(self):
        plt.plot(self.samples_t, self.samples_y)
        plt.show()

# making the oscillator 
squareOsc = SquareSignal(100, 2)
squareWave = Wave(5, squareOsc)

sinOsc = SinSignal(300, 2, 75)
sinWave = Wave(5, sinOsc)

sawOsc = SawSignal(700, 2, 180)
sawWave = Wave(5, sawOsc)

sum = (sinWave + squareWave) + sawWave
#sum.plot()

wav = np.int16(sum.samples_y * 0.1 * (2**15 - 1))

wavfile.write("Khagesh.wav", 44100, wav)